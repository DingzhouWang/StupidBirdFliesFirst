<!--
 * @Author: your name
 * @Date: 2020-05-04 21:58:09
 * @LastEditTime: 2020-05-05 21:47:16
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \StupidBirdFliesFirst\C++Fundamental\C++Fundamental.md
 -->

# C++基础知识

## C++与C语言的不同
- C++是面向对象语言，C语言是面向过程语言
- C++比C语言多了类、模板等部分
- C++有87个标准库，C有29个标准库

## C++的程序创建过程（linux）
1. 编写源代码，使用各种文本编辑器编写；
2. 预处理，处理源代码文件中的宏定义、条件编译文件、头文件等，最终生成一个没有宏定义，没有编译指令，头文件均被展开的文件；
    ```
    gcc -E hello.c -o hello.i
    ```
3. 编译，检测语法的规范性，检测有无语法错误，然后将源码生成汇编代码；
    ```
    gcc -S hello.i -o hello.s
    ```
4. 汇编，将汇编文件生成机器指令文件，即目标文件；
    ```
    gcc -c hello.s -o hello.o
    ```
5. 链接，将目标文件与其他代码链接起来，例如各种库或者启动代码，最终生成可执行文件，
   ```
   gcc hello.o -o hello
   ```
   库分为动态链接库和静态链接库两种：
   - 静态库是在链接过程中把库文件全部加入到可执行文件中，在运行时就不再需要库文件了，后缀为.a
   - 动态库在编译链接时并没有把全部代码都加入到可执行文件中去，在程序执行时再加载库，后缀为.so

    使用以上两种库时在gcc命令中刚加入-L表示查找路径，加入-l表示库名，之后将生成可执行文件。

gcc和g++其实都是可以编译c和cpp文件，但是gcc会把文件内容当成c语言，g++会把内容当成C++语言，所以这里同样需要注意。

## 内存的基本单位
&emsp;&emsp;计算机内存的基本单位是位（bit）。字节通常指的是8位的内存单元，不过在C++中有不同的定义，C++的字节表示能够容纳基本字符集的相邻位，在基本的ASCII和EBCDIC字符集中，一个字节为8位，但是也有更大的，但是一般来说还是认为一个字节有8位。

&emsp;&emsp;字是字节之上的另一个单位，通常是由CPU决定的，例如8位的CPU的话1字=1字节，16位的CPU就是1字=2字节。

## 整型数据
### 整型数据
&emsp;&emsp;整型数据包含short、int、long和long long，为了满足各种计算机的需求，C++本身不规定每一种类型的绝对长度，而是只确保最小长度：
- short至少16位
- int至少和short一样长
- long至少32位，且至少和int一样长（这意味着int可以为16位，24位，32位）
- long long至少64位，且至少和long一样长

检测长度时可以用sizeof命令，或者在头文件climits中查询。

&emsp;&emsp;C++中还包含无符号类型，只要在上述类型前加unsigned即可。其表示范围的大小没变，只是全部都是正数。

**注意，当整型数据溢出时，在数值上回在范围的另一端取值，比如无符号的整数设为0再减去1时，数值就会变为当前类型的最大值**

### 整型数据的字面值
&emsp;&emsp;整型数据在程序中写值的时候，可以有三种写法，分别表示10进制数、8进制数和16进制数：
- 10进制就直接写就行
- 8进制就是第一位先写0，然后写后面的数字，例如042，就表示十进制的34
- 16进制时先写0x或者0X，然后再写16进制的数字

&emsp;&emsp;当程序中出现常数值时，如果不带后缀的十进制数，使用int、long和long long中最小能够存储的类型存储；如果时不带后缀的八或者十六进制数，则用int、unsigned int、long、unsigned long、long long或unsigned long long表示（一般十六进制都会被存成unsigned int，因为十六进制一般用来表示地址），如果带了后缀（例如22022L就会被存成long）

### char类型
&emsp;&emsp;char比short更小，用来存储最基本的每个字符，所以其长度依据字符集中的最小单位来定（一般只要字符集里的所有符号不超过128个，就都能用一个字节来表示）。char的字面值就是字符集中表示某个字符的数字，如果直接用cout输出时即可输出其表示的字符。若是将char强制转换成int就能输出数字。在程序中给char赋值时可以用单引号包含单个字符，也可以直接赋值数字。

&emsp;&emsp;如果还需要更大的字符集，可以使用wchar_t和c++11新增的char16_t和char32_t。

### 布尔类型
&emsp;&emsp;没啥可说的，就是true和false，唯一需要注意的就是true和false都可以被提升为int类型，会变成1和0：
```
int a=true //a=1
int b=false //b=0
```
同时任何数字或者指针都可以被隐式转换成bool值，任何非零值都被转换为true，零值被转换位false

## const限定符
&emsp;&emsp;const限定符加在变量定义之前就无法在之后的程序只修改：
```
const int Months=12
```
注意最好不要先声明一个const变量，然后再定义，这样常量值一开始就不确定，也无法修改，最好就跟上面的一样，声明定义一起来。

&emsp;&emsp;const相比#define好在可以指定类型，同时可以使用c++的作用域规则将定义限制在特定区域中，而且还能将const用于结构体等更复杂的类型。

## 浮点数
&emsp;&emsp;浮点数之所以叫浮点数是因为计算机将其分为两部分存储，一部分时基准值（0到1）和缩放因子，基准值根据缩放因子移动小数点的位置，所以叫浮点数。

### 浮点数表示法
```
+5.36E+16
```

### 浮点类型
&emsp;&emsp;浮点数一般包含float，double和long double。float至少32位，其位数的表示方法是第1位表示符号；2到9表示指数（8位，所以可以表示-127到128）；10到32表示尾数（具体的数值，因为有23位，所以可以表示6到7位数字）。double也是同样的构成，1+11+52。

### 浮点常量
&emsp;&emsp;一般的浮点常量都会默认为double，需要将常量设计为其他浮点类型时需要加上f（float）或者l（long double）后缀。

### 浮点数的优缺点
优点：
- 也可以表示整数值
- 表示的范围更大（有缩放因子）
缺点：
- 计算更慢
- 精度比整型降低（因为int可以表示32位，float的尾数是23位，能表示的有效数字更少）

## 运算符
&emsp;&emsp;加减乘除求余数
### 数值转换的问题