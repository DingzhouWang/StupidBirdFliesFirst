<!--
 * @Author: your name
 * @Date: 2020-06-13 22:09:25
 * @LastEditTime: 2020-06-14 22:31:17
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \undefinedc:\Users\conan\Desktop\LongTime\StupidBirdFliesFirst\DataBase\index.md
--> 
# 索引
## B树
B树是数据库存储索引所使用的数据机构，是使用检索能够快速检索的关键。B树来源于平衡二叉树，所以现在先简单介绍一下平衡二叉树

### 平衡二叉树
平衡二叉树基于二分法，将数据按照各自的大小比较存进树中，主要有以下特点：
- 非叶子节点最多拥有两个子节点；
- 非叶子节值大于左边子节点、小于右边子节点；
- 树的左右两边的层级数相差不会大于1;
- 没有值相等重复的节点;

### B树
B树与平衡二叉树相比不用一定是每个节点最多两个子节点，它可以有更多的子节点，且每个节点可以包含多个元素：
- 每个节点有m个子节点，成为你m阶（m=2时就是二叉树）
- 每个节点包含的元素数量大于等于ceil(m/2)-1个（ceil表示向上取整）且小于m-1个
- 根节点最少可以有一个元素
- 所有叶子结点都位于同一层，或者说根结点到每个叶子结点的长度都相同
- 每个结点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。

其中这种B树的存储方式是每个节点都会存储索引及指向的数据，如图所示：
![](btree.png)

上图就是一个阶数为4的B树。可以看出每个节点存的是一组值，表示一个key对应一个value，其中key就表示数据库中的索引，value就表示指向这一行的指针（或者说是逻辑地址）。

这种查找结构从查找次数来说跟二叉树其实是差不多的，但是在把磁盘里的数据加载到内存中的时候，是以页为单位来加载的，而我们也知道，节点与节点之间的数据是不连续的，所以不同的节点，很有可能分布在不同的磁盘页中。所以对于二叉查找树，比较多少次就是要做几次寻址加载，这对于计算机来说负担是比较重的。

但是在B树种，由于每个节点可以放多个元素，所以磁盘做寻址加载的次数就更少，在计算机种，每一次做数值的比较是在内存中做的，这至少比磁盘的寻址加载速度快了几百倍，所以宁可多比较几回，也要减少寻址加载的次数。

实际上磁盘的加载次数，基本上是和树的高度相关联的，高度越高，加载次数越多，越矮，加载次数越少。所以对于这种文件索引的存储，我们一般会选择矮胖的树形结构。

#### B树的插入操作
- 根据要插入的key元素的值，找到叶子结点并插入。
- 判断当前结点元素的个数是否小于等于m-1，若满足则结束，否则进行第3步。
- 以结点中间的元素为中心分裂成左右两部分，然后将这个中间的元素插入到父结点中，这个元素的左子树指向分裂后的左半部分，这个元素的右子支指向分裂后的右半部分，然后将当前结点指向父结点，继续进行第3步。

下面以5阶B树为例，介绍B树的插入操作，在5阶B树中，结点最多有4个key,最少有2个key：
- 在空树中插入39，此时根结点就一个key，此时根结点也是叶子结点

![](https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232636141-111908062.png)

- 继续插入22，97和41，根结点此时有4个key

![](https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232641280-907189483.png)

- 继续插入53，插入后超过了最大允许的关键字个数4，所以以key值为41为中心进行分裂，结果如下图所示，分裂后当前结点指针指向父结点，满足B树条件，插入操作结束。当阶数m为偶数时，需要分裂时就不存在排序恰好在中间的key，那么我们选择中间位置的前一个key或中间位置的后一个key为中心进行分裂即可。

![](btreeinsert3.png)

![](btreeinsert4.png)

- 依次插入13，21，40，同样会造成分裂，结果如下图所示。

![](btreeinsert5.png)

- 依次插入30，27, 33 ；36，35，34 ；24，29，结果如下图所示。

![](btreeinsert6.png)

- 插入key值为26的记录，插入后的结果如下图所示。

![](btreeinsert7.png)

当前结点需要以27为中心分裂，并向父结点进位27，然后当前结点指向父结点，结果如下图所示。

![](btreeinsert8.png)

进位后导致当前结点（即根结点）也需要分裂，分裂的结果如下图所示。

![](btreeinsert9.png)

分裂后当前结点指向新的根，此时无需调整。

- 最后再依次插入key为17,28,29,31,32的记录，结果如下图所示。

![](btreeinsert10.png)

#### B树的删除操作
- 如果当前需要删除的key位于非叶子结点上，则用后继key（这里的后继key均指后继记录的意思）覆盖要删除的key，然后在后继key所在的子支中删除该后继key。此时后继key一定位于叶子结点上，这个过程和二叉搜索树删除结点的方式类似。删除这个记录后执行第2步
- 该结点key个数大于等于Math.ceil(m/2)-1，结束删除操作，否则执行第3步。
- 如果兄弟结点key个数大于Math.ceil(m/2)-1，则父结点中的key下移到该结点，兄弟结点中的一个key上移，删除操作结束。否则，将父结点中的key下移与当前结点及它的兄弟结点中的key合并，形成一个新的结点。原父结点中的key的两个孩子指针就变成了一个孩子指针，指向这个新结点。然后当前结点的指针指向父结点，重复上第2步。

有些结点它可能即有左兄弟，又有右兄弟，那么我们任意选择一个兄弟结点进行操作即可。

下面以5阶B树为例，介绍B树的删除操作，5阶B树中，结点最多有4个key,最少有2个key
- 原始状态

![](btreedelete1.png)

- 在上面的B树中删除21，删除后结点中的关键字个数仍然大于等2，所以删除结束。

![](btreedelete2.png)

- 在上述情况下接着删除27。从上图可知27位于非叶子结点中，所以用27的后继替换它。从图中可以看出，27的后继为28，我们用28替换27，然后在28（原27）的右孩子结点中删除28。删除后的结果如下图所示。

![](btreedelete3.png)

删除后发现，当前叶子结点的记录的个数小于2，而它的兄弟结点中有3个记录（当前结点还有一个右兄弟，选择右兄弟就会出现合并结点的情况，不论选哪一个都行，只是最后B树的形态会不一样而已），我们可以从兄弟结点中借取一个key。所以父结点中的28下移，兄弟结点中的26上移,删除结束。结果如下图所示。

![](btreedelete4.png)

- 在上述情况下接着32，结果如下图。

![](btreedelete5.png)

当删除后，当前结点中只key，而兄弟结点中也仅有2个key。所以只能让父结点中的30下移和这个两个孩子结点中的key合并，成为一个新的结点，当前结点的指针指向父结点。结果如下图所示。

![](btreedelete6.png)

当前结点key的个数满足条件，故删除结束。

- 上述情况下，我们接着删除key为40的记录，删除后结果如下图所示。

![](btreedelete7.png)

同理，当前结点的记录数小于2，兄弟结点中没有多余key，所以父结点中的key下移，和兄弟（这里我们选择左兄弟，选择右兄弟也可以）结点合并，合并后的指向当前结点的指针就指向了父结点。

![](btreedelete8.png)

同理，对于当前结点而言只能继续合并了，最后结果如下所示。

![](btreedelete9.png)

合并后结点当前结点满足条件，删除结束。