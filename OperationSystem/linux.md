<!--
 * @Author: your name
 * @Date: 2020-07-12 19:26:06
 * @LastEditTime: 2020-07-12 20:57:04
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \StupidBirdFliesFirst\OperationSystem\linux.md
--> 
# Linux

## Linux的权限系统
在linux中，有时候可以看到一个文件的权限如下所示：
```
-rw-r--r--
```
这9个字符表示权限。

权限分为4中，r表示读取权限，w表示写入权限，x表示执行权限，-表示无此权限。

9个字符共分为3组，每组3个字符。第1组表示创建这个文件的用户的权限，第2组表示创建创建这个文件的用户所在的组的权限，第3组表示其他用户的权限。

在每组中的3个字符里，第1个字符表示读取权限，第2个字符表示写入权限，第3个字符表示执行权限。如果有此权限，则对应位置为r，w或x，如果没有此权限，则对应位置为-。

所以说-rw-r--r--，表示这是一个普通文件，创建文件的用户的权限为rw-，创建文件的用户所在的组的权限为r--，其他用户的权限为r--。

在修改权限时，是用不同数字来表示不同权限的。4表示读取权限，2表示写入权限，1表示执行权限。

设置权限时，要给3类用户分别设置权限。

例如chmod 761表示，给创建文件的用户设置的权限是7，7=4+2+1，所以意思是给创建文件的用户赋予读取，写入和执行权限。6=4+2，也就是说给创建文件的用户所在的组赋予读取和写入权限，最后一个1表示执行权限，也就是说，给其他用户执行权限。

## Linux进程的五个段
进程（执行的程序）会占用一定数量的内存，它或是用来存放从磁盘载入的程序代码，或是存放取自用户输入的数据等等。不过进程对这些内存的管理方式因内存用途不一而不尽相同，有些内存是事先静态分配和统一回收的，而有些却是按需要动态分配和回收的。对任何一个普通进程来讲，它都会涉及到5种不同的数据段(如代码段,数据段,BSS段,堆段,栈段)。在进程被载入内存中时，基本上被分裂成主要的6个小的节（section），如, .text节, .data节, .bss节, 堆节, 栈节, 环境/参数节。

1. 代码段：代码段是用来存放可执行文件的操作指令，也就是说是它是可执行程序在内存中的镜像。代码段需要防止在运行时被非法修改，所以只准许读取操作，而不允许写入（修改）操作——它是不可写的。代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。
2. 数据段：数据段用来存放可执行文件中已初始化全局变量，换句话说就是存放程序静态分配的变量和全局变量。
3. BSS段：BSS段包含了程序中未初始化的全局变量，在内存中 bss段全部置零。BSS段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。
4. 堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）它的物理内存空间是由程序申请的，并由程序负责释放。
5. 栈：栈又称堆栈，栈是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。它是由操作系统分配的，内存的申请与回收都由OS管理。

以上这几个段中，堆、BSS、数据段这三个段再物理内存中是连续存放的，代码段和栈是独立的。

在进程被载入内存中时，基本上被分裂成许多小的节（section）。我们比较关注的是6个主要的节：

1. text 节：.text 节基本上相当于二进制可执行文件的.text部分，它包含了完成程序任务的机器指令。该节标记为只读，如果发生写操作，会造成segmentation fault。在进程最初被加载到内存中开始，该节的大小就被固定。

2. data 节：.data节用来存储初始化过的变量，如：int a =0 ; 该节的大小在运行时固定的。

3. bss 节：栈下节（belowstack section ,即.bss）用来存储未初始化的变量，如：int a; 该节的大小在运行时固定的。

4. 堆节：堆节（heapsection）用来存储动态分配的变量，位置从内存的低地址向高地址增长。内存的分配和释放通过malloc() 和 free() 函数控制。

5. 栈节栈节（stacksection）用来跟踪函数调用（可能是递归的），在大多数系统上从内存的高地址向低地址增长。同时，栈这种增长方式，导致了缓冲区溢出的可能性。

6. 环境/参数节：环境/参数节（environment/argumentssection）用来存储系统环境变量的一份复制文件，进程在运行时可能需要。例如，运行中的进程，可以通过环境变量来访问路径、shell 名称、主机名等信息。该节是可写的，因此在格式串（format string）和缓冲区溢出（buffer overflow）攻击中都可以使用该节。另外，命令行参数也保持在该区域中。

## select epoll

## 硬链接和软连接
在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号inode 。软连接，其实就是新建立一个文件，这个文件就是专门用来指向别的文件的（那就和windows 下的快捷方式的那个文件有很接近的意味）。软链接产生的是一个新的文件，但这个文件的作用就是专门指向某个文件的，删了这个软连接文件，那就等于不需要这个连接，和原来的存在的实体原文件没有任何关系，但删除原来的文件，则相应的软连接不可用（cat那个软链接文件，则提示“没有该文件或目录“）

硬连接是不会建立inode的，他只是在文件原来的inode link count域再增加1而已，也因此硬链接是不可以跨越文件系统的。相反软连接会重新建立一个inode，当然inode的结构跟其他的不一样，他只是一个指明源文件的字符串信息。一旦删除源文件，那么软连接将变得毫无意义。而硬链接删除的时候，系统调用会检查inode link count的数值，如果他大于等于1，那么inode不会被回收。因此文件的内容不会被删除。
硬链接实际上是为文件建一个别名，链接文件和原文件实际上是同一个文件。可以通过ls -i来查看一下，这两个文件的inode号是同一个，说明它们是同一个文件；而软链接建立的是一个指向，即链接文件内的内容是指向原文件的指针，它们是两个文件。
软链接可以跨文件系统，硬链接不可以；软链接可以对一个不存在的文件名(filename)进行链接（当然此时如果你vi这个软链接文件，linux会自动新建一个文件名为filename的文件）,硬链接不可以（其文件必须存在，inode必须存在）；软链接可以对目录进行连接，硬链接不可以。两种链接都可以通过命令 ln 来创建。ln 默认创建的是硬链接。使用 -s 开关可以创建软链接。

## chmod命令
cat命令的用途是连接文件或标准输入并打印。这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。 

cat主要有三大功能：
1. 一次显示整个文件:cat filename
2. 从键盘创建一个文件:cat > filename 只能创建新文件,不能编辑已有文件.
3. 将几个文件合并为一个文件:cat file1 file2 > file

## ifconfig命令
作用：ifconfig用于查看和更改网络接口的地址和参数，包括IP地址、网络掩码、广播地址，使用权限是超级用户。

格式    ifconfig -interface [options] address

主要参数如下：

-interface：指定的网络接口名，如eth0和eth1。

up：激活指定的网络接口卡。

down：关闭指定的网络接口。

broadcast address：设置接口的广播地址。

pointopoint：启用点对点方式。

address：设置指定接口设备的IP地址。

netmask address：设置接口的子网掩码。

## etc文件下的内容
/etc/resolv.conf 是DNS配置文件。在网卡配置文件中进行配置，默认情况下 网卡配置文件DNS优先于/etc/resolv.conf。

/etc/hostname 在Centos 7，配置主机名，查看修改。

/etc/hosts hosts文件包含了ip地址与主机名之间的映射，还包括主机的别名。在没有域名解析服务器的情况下，系统上的所有网络程序都通过查询该文件来解析对应于某个主机名的ip地址，否则就需要使用dns服务程序来解决。通过可以将常用的域名和ip地址映射加入到hosts文件中，实现快速方便的访问。

/etc/gateways 设置路由器

/etc/fstab file system table ：文件系统挂载表，开机的时候设备与入口对应关系 开机自动挂载列表。

/etc/rc.local 开机自启

/etc/inittab（centos 6）运行级别的配置文件

/etc/profile 环境变量配置文件

/etc/bashrc 命令别名

/etc/motd 文件中的内容 会在用户登录系统之后显示出来

/etc/issue /etc/issue.net 文件中的内容 会在用户登录系统之前显示出来

## proc文件夹下内容
大量有关当前系统状态的信息

/proc/cmdline：文件给出了内核启动的命令行

/proc/cpuinfo：文件提供了有关系统CPU的信息

/proc/devices：文件列出字符和设备的主设备号，以及分配这些设备号的设备名称

/proc/dma：文件列出驱动程序保留的DMA通道和保留他们的驱动程序名称

/proc/filesystems：文件列出可供使用的文件系统类型

/proc//interrupts：文件的每一行都有一个保留的中断号

/proc/ioports：文件列出了磁盘驱动器，以太网卡，声卡设备等多种设备驱动程序登记的IO端口范围

/proc/kcore：文件是系统的物理内存以core文件格式保存的文件

/proc/kmsg：文件用于检索用printk生成的内核消息

/proc/ksyms：文件列出了已经等级的内核符号，这些符号给出了变量或函数地址，每行给出一个符号的地址，符号名称以及登记这个符号的模块。程序ksyms,insmod和kmod使用这个文件。它还列出了正在运行的任务数，总任务数和最后分配的PID。

/proc/loadavg：这个文件给出几个不同时间间隔计算的系统平均负载，如同uptime命令

/proc/locks：文件包含在打开的文件上的加锁信息

/proc/mdstat：文件包含了由md设备驱动程序控制的RAID设备信息

/proc/meminfo：文件给出了内存状态的信息，如同free命令

/proc/misc：文显示用内核函数misc_register登记的设备驱动程序

/proc/modules：文件显示可加载内核模块的信息

/proc/mounts：文件以/etc/mtab文件的格式给出当前系统所安装的文件系统信息

/proc/pcl：文件显示PCI设备信息

/proc/stat：文件包含的信息有CPU利用率，磁盘，内存页，内存对换，全部中断，接触开关，上次自举时间

/proc/uptime：文件显示从上次系统自举以来的秒数，以及其中有多少秒处于空闲

/proc/version：文件显示正在运行的内核版本

/proc//net子目录：目录下的文件描述或修改了联网代码的行为，通过使用arp,netstat,route和ipfwadm命令设置或查询这些特殊文件中的许多文件。

/proc/scsi子目录：目录下包含了一个列出了所有检测到的SCSI设备文件，为没中控制驱动器提供一个目录

/proc/sys子目录：用以调整系统的性能

## echo
echo用于在shell中打印shell变量的值，或者直接输出指定的字符串

## env
env用于显示系统中已存在的环境变量，以及在定义的环境中执行指令

## export
export用于将shell变量输出为环境变量，或者将shell函数输出为环境变量

## du
du命令可以显示目前的目录所占的磁盘空间：

选项：

-h 人类可读方式

-a：显示目录所占空间大小，同时显示旗下目录和文件所占用磁盘空间

-s：显示目标所占大小，不显示旗下目录和文件占用磁盘空间大小

-c：显示几个目录或文件的磁盘空间大小，统计总和

-apparent-size:：显示目录或文件的自身大小

-l：统计硬链接所占空间大小

-L：统计符号链接所指向的文件所占用的磁盘空间大小

## more命令
分屏显示文件内容，每次只显示一屏，只允许向前浏览。

## ess命令
与more相似，并且支持向前，向后浏览。

## wc命令
Linux系统中的wc (Word Count) 命令的功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出。

命令参数：

-c 统计字节数。

-l 统计行数。

-m 统计字符数。这个标志不能与 -c 标志一起使用。

-w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。

-L 打印最长行的长度。

-help 显示帮助信息

--version 显示版本信息

## vi指令
### 查找字符串
/ 从上到下查找
? 从下到上查找